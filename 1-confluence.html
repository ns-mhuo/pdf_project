<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Confluence-Ready HTML</title>
    
    <style>
    /* Confluence Page Styling */
    .wiki-content {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        line-height: 1.6;
        color: #172b4d;
        max-width: 100%;
        margin: 0;
        padding: 0;
    }
    
    /* Headers */
    h1 { 
        color: #0052cc; 
        border-bottom: 2px solid #0052cc; 
        padding-bottom: 8px;
        margin-top: 0;
        font-size: 1.8em;
    }
    h2 { 
        color: #0065ff; 
        margin-top: 32px;
        margin-bottom: 16px;
        font-size: 1.4em;
        padding-left: 0;
        border-left: 3px solid #0065ff;
        padding-left: 12px;
    }
    h3 { 
        color: #0052cc; 
        margin-top: 24px;
        margin-bottom: 12px;
        font-size: 1.2em;
    }
    h4 { 
        color: #172b4d; 
        margin-top: 20px;
        margin-bottom: 10px;
        font-weight: 600;
        font-size: 1.1em;
    }
    
    /* Code styling */
    pre {
        background: #f4f5f7;
        border: 1px solid #dfe1e6;
        border-radius: 3px;
        padding: 12px;
        overflow-x: auto;
        margin: 16px 0;
        font-family: 'SFMono-Regular', Consolas, monospace;
        font-size: 0.9em;
        line-height: 1.4;
    }
    
    code {
        background: #f4f5f7;
        color: #172b4d;
        padding: 2px 4px;
        border-radius: 3px;
        font-family: 'SFMono-Regular', Consolas, monospace;
        font-size: 0.9em;
    }
    
    /* Tables */
    table {
        border-collapse: collapse;
        width: 100%;
        margin: 16px 0;
        border: 1px solid #dfe1e6;
    }
    
    th {
        background: #f4f5f7;
        color: #172b4d;
        padding: 8px 12px;
        text-align: left;
        font-weight: 600;
        border: 1px solid #dfe1e6;
    }
    
    td {
        padding: 8px 12px;
        border: 1px solid #dfe1e6;
        vertical-align: top;
    }
    
    tr:nth-child(even) {
        background: #f8f9fa;
    }
    
    /* Lists */
    ul, ol {
        margin: 12px 0;
        padding-left: 24px;
    }
    
    li {
        margin: 6px 0;
        line-height: 1.5;
    }
    
    /* Status indicators */
    li:contains('✅') {
        color: #00875a;
    }
    
    li:contains('🔄') {
        color: #ff8b00;
    }
    
    /* Links */
    a {
        color: #0052cc;
        text-decoration: none;
    }
    
    a:hover {
        color: #0065ff;
        text-decoration: underline;
    }
    
    /* Paragraphs */
    p {
        margin: 12px 0;
        line-height: 1.6;
    }
    
    /* Info panels */
    .panel {
        border: 1px solid #dfe1e6;
        border-radius: 3px;
        margin: 16px 0;
    }
    
    .panel-info {
        border-left: 3px solid #0052cc;
        background: #e6f7ff;
    }
    
    .panel-success {
        border-left: 3px solid #00875a;
        background: #e3fcef;
    }
    
    .panel-warning {
        border-left: 3px solid #ff8b00;
        background: #fffbf0;
    }
    
    .panel-body {
        padding: 12px;
    }
    </style>
    
</head>
<body>
    <div class="wiki-content">
        <h1>Netskope Proxy Routing Automation Documentation</h1>
<h2>Overview</h2>
<p>This document describes the automated routing configuration system for Netskope proxy (nsproxy) infrastructure, which handles Direct Server Return (DSR), egress NAT, and multi-gateway routing across different datacenters and cloud environments.</p>
<p><strong>Key Features:</strong>
<ul>
<li><strong>Multi-Service Support</strong>: Works with netplan-only, networking service-only, or both active</li>
<li><strong>Automatic Detection</strong>: Intelligently detects available networking services</li>
<li><strong>Dual Configuration</strong>: Generates both legacy ifupdown and modern netplan formats</li>
<li><strong>Zero Downtime</strong>: Ensures DSR functionality regardless of networking backend</li>
</ul></p>
<h2>Multi-Service Networking Support</h2>
<h3>Service Detection and Compatibility</h3>
<p>The routing automation system automatically detects and supports three networking service scenarios:</p>
<p><h4>1. Netplan-Only Mode</h4>
<ul>
<li><strong>Environment</strong>: Modern Ubuntu 20.04 LTS with systemd-networkd active</li>
<li><strong>Detection</strong>: Script detects netplan binary and YAML configuration files</li>
<li><strong>Configuration</strong>: Generates <code>/etc/netplan/99-nslbrsrouting-generated.yaml</code></li>
<li><strong>Benefits</strong>: Native systemd-networkd integration, declarative configuration</li>
</ul></p>
<p><h4>2. Networking Service-Only Mode</h4>
<ul>
<li><strong>Environment</strong>: Traditional Ubuntu systems with ifupdown networking</li>
<li><strong>Detection</strong>: Script detects <code>/etc/init.d/networking</code> or systemd networking.service</li>
<li><strong>Configuration</strong>: Generates ifupdown-style rule files in <code>/etc/network/</code></li>
<li><strong>Benefits</strong>: Proven stability, wide compatibility</li>
</ul></p>
<p><h4>3. Both Services Active Mode</h4>
<ul>
<li><strong>Environment</strong>: Transition/compatibility systems with both services available</li>
<li><strong>Detection</strong>: Script detects both netplan and networking service present</li>
<li><strong>Configuration</strong>: Generates <strong>BOTH</strong> configuration formats</li>
<li><strong>Benefits</strong>: Maximum compatibility, smooth migration path</li>
</ul></p>
<h3>Service Detection Logic</h3>
<pre><code>def detect_networking_services():
    ''' Intelligent detection of available networking services '''
    services = {
        'netplan': False,          # Checks for netplan binary and config files
        'networking': False,       # Checks for traditional networking service  
        'systemd_networkd': False  # Checks systemctl status
    }
    
    # Detection methods:
    # 1. Check for netplan binary in /usr/sbin/ or /usr/bin/
    # 2. Scan /etc/netplan/, /run/netplan/, /lib/netplan/ for YAML files
    # 3. Check for networking service files
    # 4. Query systemctl for systemd-networkd status</code></pre>
<h3>Configuration Generation Strategy</h3>
<table>
<tr>
<th>Service State</th>
<th>Generated Configurations</th>
<th>Primary Method</th>
<th>Fallback Method</th>
</tr>
<tr>
<td>Netplan Only</td>
<td>Netplan YAML + ifupdown rules</td>
<td>systemd-networkd</td>
<td>Manual ifupdown</td>
</tr>
<tr>
<td>Networking Only</td>
<td>ifupdown rules only</td>
<td>networking service</td>
<td>N/A</td>
</tr>
<tr>
<td>Both Active</td>
<td>Netplan YAML + ifupdown rules</td>
<td>systemd-networkd</td>
<td>networking service</td>
</tr>
<tr>
<td>Neither Detected</td>
<td>Both configurations</td>
<td>Manual activation</td>
<td>Manual activation</td>
</tr>
</table>
<h2>Architecture Components</h2>
<h3>Core Scripts</h3>
<p><h4>1. deploy_routing.py</h4>
<ul>
<li><strong>Purpose</strong>: Configures complex routing for nsproxy load balancers with DSR and Egress NAT policies</li>
<li><strong>Location</strong>: <code>automation/playbooks/roles/nslbrsrouting/files/deploy_routing.py</code></li>
<li><strong>Output Formats</strong>: Supports both legacy ifupdown and modern netplan/systemd-networkd configurations</li>
</ul></p>
<p><h4>2. install-routes.py</h4>
<ul>
<li><strong>Purpose</strong>: Installs reverse-path routing for gateway routes and VIP rules</li>
<li><strong>Location</strong>: <code>automation/playbooks/roles/nsproxy_revroutes/files/install-routes.py</code></li>
<li><strong>Configuration Source</strong>: Reads from <code>/tmp/vars_install_routes</code> (generated by Ansible template)</li>
</ul></p>
<h3>Ansible Integration</h3>
<p><h4>Roles Structure</h4>
<pre><code>automation/playbooks/roles/
├── nslbrsrouting/           # Main routing configuration
│   ├── files/
│   │   ├── deploy_routing.py    # Main routing script
│   │   ├── 99-ns-config         # Interface up/down hook script
│   │   └── test_deploy_routing.py
│   └── tasks/main.yml       # Orchestrates multiple script invocations
└── nsproxy_revroutes/       # Reverse routing configuration
    ├── files/
    │   ├── install-routes.py
    │   └── test_install_routes.py
    ├── templates/
    │   └── source.list.j2   # Generates /tmp/vars_install_routes
    └── tasks/main.yml       # Reverse route configuration tasks</code></pre></p>
<p><h4>System Dependencies</h4>
The automation installs required system packages:
<pre><code><h1>Package dependencies installed via Ansible</h1>
apt:
  <ul>
<li>arptables          # ARP table management</li>
</ul>
  <ul>
<li>python3-netifaces # Network interface introspection</code></pre></li>
</ul></p>
<h2>Script Execution Flow</h2>
<h3>1. Ansible Orchestration Sequence</h3>
<p><h4>Phase 0: Environment Setup and Dependency Installation</h4>
<pre><code><h1>Environment detection</h1>
<ul>
<li>set_fact:</li>
</ul>
    awsenv: true
  when: NSLB_EGRESS_GW_VIP is defined</p>
<p><h1>System package installation</h1>
<ul>
<li>name: Apt Component Dependency Install</li>
</ul>
  apt:
    name: "{{item}}"
    state: present
  with_items:
    - arptables
    - python3-netifaces</p>
<p><h1>Script deployment</h1>
<ul>
<li>name: Copy python script to host</li>
</ul>
  copy: src=deploy_routing.py dest=/usr/bin/deploy_routing.py owner=root group=root mode=0755</p>
<p><h1>Interface hook scripts</h1>
<ul>
<li>name: Copy if-up.d script</li>
</ul>
  copy: src=99-ns-config dest=/etc/network/if-up.d/99-ns-config owner=root group=root mode=0755
<ul>
<li>name: Copy if-down.d script</li>
</ul>
  copy: src=99-ns-config dest=/etc/network/if-down.d/99-ns-config owner=root group=root mode=0755</code></pre></p>
<p><h4>Phase 1: Template Generation</h4>
<pre><code><h1>Ansible renders source.list.j2 template</h1>
Template: nsproxy_revroutes/templates/source.list.j2
Output: /tmp/vars_install_routes
Content: Gateway pools and VIP configurations from inventory</code></pre></p>
<p><h4>Phase 2: Route Deployment (deploy_routing.py)</h4>
Environment-aware executions with conditional logic:</p>
<pre><code><h1>NSGW Gateway Configuration (Physical vs AWS)</h1>
<h1>Physical DC:</h1>
/usr/bin/deploy_routing.py -O GW_LVS_DSR -L {{NSGW_DEFAULT_GW}} -P {{NSGW_DEFAULT_SUBNET}} \
  -F {{ARISTA_EGRESS_GW}} -Q {{NSGW_DEFAULT_SUBNET}} -V {{NSGW_LB_VIP}} -I {{EGRESS_IF_NAME}}
<h1>AWS DC: (same command, different variable values)</h1></p>
<p><h1>IOSVPN Gateway Configuration</h1>
/usr/bin/deploy_routing.py -O GW_LVS_DSR -L {{NSGW_DEFAULT_GW}} -P {{NSGW_DEFAULT_SUBNET}} \
  -F {{ARISTA_EGRESS_GW}} -Q {{NSGW_DEFAULT_SUBNET}} -V {{IOSVPN_LB_VIP}} -I {{EGRESS_IF_NAME}}
<h1>Conditional: when inventory_hostname in groups['ssvpn']</h1></p>
<p><h1>IPSEC Gateway Configuration  </h1>
/usr/bin/deploy_routing.py -O GW_LVS_DSR -L {{NSGW_DEFAULT_GW}} -P {{NSGW_DEFAULT_SUBNET}} \
  -F {{ARISTA_EGRESS_GW}} -Q {{NSGW_DEFAULT_SUBNET}} -V {{IPSECGW_LB_VIP}} -I {{EGRESS_IF_NAME}}
<h1>Conditional: when inventory_hostname in groups['ipsecgw']</h1></p>
<p><h1>GREGW Gateway Configuration</h1>
/usr/bin/deploy_routing.py -O GW_LVS_DSR -L {{NSGW_DEFAULT_GW}} -P {{NSGW_DEFAULT_SUBNET}} \
  -F {{ARISTA_EGRESS_GW}} -Q {{NSGW_DEFAULT_SUBNET}} -V {{GREGW_LB_VIP}} -I {{EGRESS_IF_NAME}}
<h1>Conditional: when inventory_hostname in groups['nsgregw']</h1></p>
<p><h1>Egress NAT Configuration (Dynamic Interface)</h1>
/usr/bin/deploy_routing.py -O NSPROXY_EGRESS_NAT -A "{{EGRESS_NAT_NEXTHOPS}}" \
  -H "{{PXY_EGRESS_NAT_HC_HOSTS}}" -E {{ egress_nat_if_name }}
<h1>Default interface: bond0.410 (configurable via EGRESS_NAT_IF_NAME)</h1></p>
<p><h1>China-Specific Multi-VIP Configuration</h1>
/usr/bin/deploy_routing.py -O GW_LVS_DSR -L {{NSGW_DEFAULT_GW}} -P {{NSGW_DEFAULT_SUBNET}} \
  -F {{ARISTA_EGRESS_GW}} -Q {{NSGW_DEFAULT_SUBNET}} \
  -V "{{ NSGW_LB_VIP + ',' + IPSECGW_LB_VIP + ',' + IOSVPN_LB_VIP + ',' + GREGW_LB_VIP + ',' + PROXY_CHAIN_LB_VIP + ',' + SECURE_FORWARDER_LB_VIP }}" \
  -I {{EGRESS_IF_NAME}}
<h1>Conditional: when PRC_DP_POP is defined and inventory_hostname in groups['dpsvclb']</h1></code></pre>
<p><h4>Phase 3: Reverse Route Installation (install-routes.py)</h4>
<pre><code><h1>Template-driven route installation</h1>
script: "install-routes.py {{ SERVICE_INGRESS_IF_NAME }}"
<h1>Reads configuration from /tmp/vars_install_routes</h1>
<h1>Installs reverse-path routes for gateway pools</h1>
<h1>Conditional: when NSPROXY_NORMAL_VIP, NSPROXY_STAGGERED_VIP, NSPROXY_DEBUG_VIP are defined</h1>
</code></pre></p>
<p><h4>Phase 4: Interface Hook Management</h4>
<pre><code><h1>Interface state management via 99-ns-config hook script</h1></p>
<p><h1>Disable egress interface</h1>
/etc/network/if-up.d/99-ns-config
<h1>Environment: MODE=stop, IFACE={{ egress_nat_if_name }}, ADDRFAM=inet</h1></p>
<p><h1>Enable egress interface  </h1>
/etc/network/if-up.d/99-ns-config
<h1>Environment: MODE=start, IFACE={{ egress_nat_if_name }}, ADDRFAM=inet</h1></p>
<p><h1>Configure Gateway reverse routes</h1>
/etc/network/if-up.d/99-ns-config
<h1>Environment: MODE=start, IFACE={{ SERVICE_INGRESS_IF_NAME }}, ADDRFAM=inet</h1>
</code></pre></p>
<p><h4>Hook Script Capabilities (99-ns-config)</h4>
The interface hook script supports comprehensive network configuration:</p>
<pre><code><h1>Supported operations:</h1>
<h1>- rule: Add/remove policy routing rules</h1>
<h1>- route: Add/remove static routes  </h1>
<h1>- arptables: Manage ARP table entries</h1>
<h1>- route_table: Create custom routing tables</h1>
<h1>- addr: Manage IP addresses</h1>
<h1>- ifconfig: Interface configuration</h1>
<h1>- iptables: Firewall rule management</h1></p>
<p><h1>Executes rules from:</h1>
<h1>/etc/network/ns_configure_rules.<em>.ROUTING (for interface up)</h1>
<h1>/etc/network/ns_deconfigure_rules.</em>.ROUTING (for interface down)</h1>
</code></pre>
<h3>2. Command-Line Arguments Reference</h3>
<p>| Argument 
| Purpose 
| Example Value </p>
<p>| <code>-O</code> 
| Operation mode 
| <code>GW_LVS_DSR</code>, <code>NSPROXY_EGRESS_NAT</code> </p>
<p>| <code>-V</code> 
| VIP (Virtual IP) address 
| <code>172.16.1.100</code> </p>
<p>| <code>-L</code> 
| Physical gateway IPs (comma-separated) 
| <code>172.16.1.10,172.16.1.11</code> </p>
<p>| <code>-E</code> 
| Egress NAT VIP address 
| <code>10.0.1.50</code> </p>
<p>| <code>-F</code> 
| Forward IP for egress NAT 
| <code>10.0.1.1</code> </p>
<p>| <code>-D</code> 
| Datacenter identifier 
| <code>aws</code>, <code>lax1</code>, <code>fra4</code> </p>
<h2>Network Configuration Logic</h2>
<h3>Interface Discovery Process</h3>
<p><h4>deploy_routing.py Interface Detection</h4>
<pre><code><h1>1. Discover all network interfaces using netifaces</h1>
interfaces = netifaces.interfaces()</p>
<p><h1>2. For each interface, get IP configuration</h1>
for interface in interfaces:
    addrs = netifaces.ifaddresses(interface)
    
<h1>3. Match interface IPs to network subnets</h1>
<h1>4. Determine primary interface for routing</h1>
</code></pre></p>
<p><h4>Hostname and IP Resolution</h4>
<pre><code><h1>1. Get local hostname</h1>
hostname = socket.getfqdn()</p>
<p><h1>2. Resolve hostname to IP addresses</h1>
host_ips = socket.getaddrinfo(hostname, None)</p>
<p><h1>3. Match resolved IPs to discovered interfaces</h1>
<h1>4. Select appropriate interface for routing configuration</h1>
</code></pre></p>
<h3>Configuration File Generation</h3>
<p><h4>Dual-Format Support</h4>
The scripts generate configurations for both networking systems to ensure DSR works in all scenarios:</p>
<p><strong>Legacy ifupdown format:</strong></p>
<pre><code><h1>/etc/network/ns_configure_rules.ROUTING</h1>
<h1>Traditional rule-based configuration for networking service</h1>
eth0: route replace default via 172.16.1.1 dev eth0 table 100
eth0: rule add from 172.16.1.100 table 100 pref 32500
eth0: route replace 172.20.0.0/16 via 172.16.1.10 table 100
</code></pre>
<p><strong>Modern netplan format:</strong></p>
<pre><code><h1>/etc/netplan/99-nslbrsrouting-generated.yaml</h1>
<h1>Declarative YAML configuration for systemd-networkd</h1>
network:
  version: 2
  renderer: networkd
  ethernets:
    eth0:
      routes:
        - to: default
          via: 172.16.1.1
          table: 100
          metric: 99
        - to: 172.20.0.0/16
          via: 172.16.1.10
          table: 100
      routing-policy:
        - from: 172.16.1.100
          table: 100
          priority: 32500
</code></pre>
<p><strong>Service Compatibility Matrix:</strong></p>
<p>| Ubuntu Version 
| Default Networking 
| Supported Configuration 
| DSR Status </p>
<p>| 16.04 LTS 
| networking service 
| ifupdown rules 
| Fully Supported </p>
<p>| 18.04 LTS 
| netplan + networking 
| Both formats 
| Fully Supported </p>
<p>| 20.04 LTS 
| netplan + systemd-networkd 
| Both formats 
| Fully Supported </p>
<h3>Routing Table Management</h3>
<p><h4>DSR (Direct Server Return) Configuration</h4>
<pre><code><h1>1. Create dummy interfaces for VIPs</h1>
ip link add dummy0 type dummy
ip addr add 172.16.1.100/32 dev dummy0</p>
<p><h1>2. Configure policy routing tables</h1>
echo "100 nsproxy_table" >> /etc/iproute2/rt_tables</p>
<p><h1>3. Add routes to routing table</h1>
ip route add 172.20.0.0/16 via 172.16.1.10 table 100</p>
<p><h1>4. Configure policy rules</h1>
ip rule add from 172.16.1.100 table 100
</code></pre></p>
<p><h4>Egress NAT Configuration</h4>
<pre><code><h1>1. Configure egress VIP on dummy interface</h1>
ip addr add 10.0.1.50/32 dev dummy1</p>
<p><h1>2. Set up NAT forwarding rules</h1>
ip route add default via 10.0.1.1 table 200</p>
<p><h1>3. Policy routing for egress traffic</h1>
ip rule add from 10.0.1.50 table 200
</code></pre></p>
<h2>Ansible Variable Flow</h2>
<p><h3>Inventory Structure</h3>
<pre><code><h1>group_vars/edge-nsproxy.yml</h1>
NSGW_LB_VIP: "172.16.1.100"
NSGW_PHYS_DC_IPS: ["172.16.1.10", "172.16.1.11"]
IOSVPN_LB_VIP: "172.16.1.101"
IOSVPN_GW_IPS: ["172.16.1.20", "172.16.1.21"]
EGRESS_NAT_VIP: "10.0.1.50"
FWD_IP: "10.0.1.1"
datacenter: "lax1"
</code></pre></p>
<p><h3>Template Processing</h3>
<pre><code>{# nsproxy_revroutes/templates/source.list.j2 #}
{% for pool in GW_POOL %}
{{ pool.name }}={{ pool.gw_ips|join(',') }}
{% endfor %}</p>
<p>{% for vip in VIP_LIST %}
{{ vip.name }}={{ vip.ip }}
{% endfor %}
</code></pre></p>
<p><h3>Generated Configuration File</h3>
<pre><code><h1>/tmp/vars_install_routes</h1>
NSGW_POOL=172.16.1.10,172.16.1.11
IOSVPN_POOL=172.16.1.20,172.16.1.21
NSGW_VIP=172.16.1.100
IOSVPN_VIP=172.16.1.101
</code></pre></p>
<h2>Deployment Integration</h2>
<h3>Role Integration Methods</h3>
<p><h4>Method 1: Additional Roles in Main Playbooks</h4>
<pre><code><h1>install_serial_playbook.yml</h1>
roles:
  <ul>
<li>{ role: '{{ addl_role1|default("noop") }}' }</li>
</ul>
  <ul>
<li>{ role: '{{ addl_role2|default("noop") }}' }</li>
</ul></p>
<p><h1>Variables passed:</h1>
addl_role1: "nslbrsrouting"
addl_role2: "nsproxy_revroutes"
</code></pre></p>
<p><h4>Method 2: Service-Specific Inclusion</h4>
<pre><code><h1>During nsproxy service installation</h1>
<ul>
<li>include_role:</li>
</ul>
    name: nslbrsrouting
<ul>
<li>include_role:</li>
</ul>
    name: nsproxy_revroutes
</code></pre></p>
<h3>Environment Support</h3>
<p><h4>Multi-Datacenter Deployment</h4>
<ul>
<li><strong>Physical DCs</strong>: LAX1, FRA4, SIN1, etc.</li>
<li><strong>Cloud Environments</strong>: AWS, GCP, Azure</li>
<li><strong>Hybrid Configurations</strong>: Mixed physical/cloud setups</li>
</ul></p>
<p><h4>Network Scenarios</h4>
<ul>
<li><strong>DSR Load Balancing</strong>: Direct server return for high-performance routing</li>
<li><strong>Egress NAT</strong>: Outbound traffic management</li>
<li><strong>Multi-Gateway</strong>: Redundant gateway configurations</li>
<li><strong>VIP Management</strong>: Virtual IP distribution across services</li>
</ul></p>
<h2>Manual Configuration Procedures</h2>
<h3>Legacy Manual Setup (Pre-Automation)</h3>
<p>For reference and troubleshooting, here are the manual configuration steps that the automation replaces:</p>
<p><h4>Manual Routing Table Configuration</h4>
<pre><code><h1>Add ingress routing table to /etc/iproute2/rt_tables</h1>
echo "1 ingress_table" >> /etc/iproute2/rt_tables</p>
<p><h1>Verify table was added</h1>
cat /etc/iproute2/rt_tables
<h1>Output should include:</h1>
<h1>1 ingress_table</h1>
</code></pre></p>
<p><h4>Manual Interface Configuration (Legacy)</h4>
<strong>Example SV5 configuration in /etc/network/interfaces:</strong></p>
<pre><code><h1>Management Network Traffic</h1>
auto bond0
iface bond0 inet static
address ${dppool13-1.mgt.sv5.nskope.net}
netmask 255.255.252.0
bond-miimon 100
bond-slaves eth2 eth3
bond-mode 802.3ad</p>
<p><h1>Virtual LAN for Production Traffic</h1>
auto bond0.400
iface bond0.400 inet static
address ${dppool13-1-out.sv5.nskope.net}
netmask 255.255.254.0
gateway 192.168.100.1
vlan-raw-device bond0</p>
<p><h1>DSR Interface Alias</h1>
auto bond0.400:1
iface bond0.400:1 inet static
address ${dppool13-1.sv5.nskope.net}
netmask 255.255.254.0
<h1>Manual DSR routing rules</h1>
up ip route del default
up ip route add default dev bond0.400 via 192.168.100.1 src ${dppool13-1-out.sv5.nskope.net}
up ip addr add ${dppool13-1-egress.sv5.nskope.net}/23 dev bond0.400
up ip rule add from ${dppool13-1.sv5.nskope.net} table ingress_table pref 32690
up ip route add default via 192.168.100.1 dev bond0.400 table ingress_table metric 99
up ip rule add from all to 192.168.106.0/23 table main pref 32700
up ip rule add from all to 172.16.0.0/12 table ingress_table pref 32730
up ip rule add from all to 10.0.0.0/8 table ingress_table pref 32740
up ip rule add from all to 192.168.0.0/16 table ingress_table pref 32750
</code></pre>
<p><h4>Additional VLAN Interface Setup</h4>
<strong>VLAN 600/601 configuration for nsproxy hosts:</strong></p>
<pre><code><h1>VLAN 600 Interface</h1>
auto bond0.600
iface bond0.600 inet static
mtu 9000
address 
netmask 255.255.255.128
vlan-raw-device bond0</p>
<p><h1>VLAN 601 Interface</h1>
auto bond0.601
iface bond0.601 inet static
mtu 9000
address 
netmask 255.255.255.128
vlan-raw-device bond0</p>
<p><h1>Bring up interfaces</h1>
sudo ifup bond0.600
sudo ifup bond0.601
</code></pre>
<p><h4>Interface Protection</h4>
<pre><code><h1>Make interfaces file immutable (prevent accidental changes)</h1>
sudo chattr +i /etc/network/interfaces</p>
<p><h1>Remove immutable attribute when editing needed</h1>
sudo chattr -i /etc/network/interfaces
</code></pre></p>
<h3>Modern Automated vs Manual Comparison</h3>
<p>| Configuration Aspect 
| Manual Method (Legacy) 
| Automated Method (Current) 
| Benefits of Automation </p>
<p>| <strong>Routing Table Setup</strong> 
| Manual editing of /etc/iproute2/rt_tables 
| Automatic via deploy_routing.py + 99-ns-config 
| Consistent naming, no human error </p>
<p>| <strong>Policy Rules</strong> 
| Manual ip rule commands in interfaces file 
| Generated rules in ns_configure_rules files 
| Environment-aware, templated </p>
<p>| <strong>Service Detection</strong> 
| Manual determination of networking backend 
| Automatic detection + dual configuration 
| Ubuntu version agnostic </p>
<p>| <strong>Configuration Format</strong> 
| Single ifupdown format 
| Dual: ifupdown + netplan YAML 
| Future-proof compatibility </p>
<p>| <strong>Error Handling</strong> 
| Manual verification required 
| Atomic file writes, validation checks 
| Reduced deployment failures </p>
<h2>Jenkins Integration and Automation Workflows</h2>
<h3>Post-Deployment Jenkins Jobs</h3>
<p><h4>Required Jenkins Jobs Sequence</h4>
<pre><code><h1>1. Infrastructure Inventory Update</h1>
Job: http://ppe-jenkins01.sv5.nskope.net:8080/job/infrastructure
Purpose: Pull latest inventory from infrastructure repo
Frequency: Hourly (automated) + manual trigger after new hosts</p>
<p><h1>2. Proxy Reverse Routes Configuration  </h1>
Job: http://dpjenkins01.{pop}.nskope.net:8080/job/ansible_proxy_reverse_routes/
Purpose: Configure reverse routes for gateway pools
Trigger: After inventory update, before LCO deployment
Parameters: Runs against all proxy nodes in site</p>
<p><h1>3. NAT Rules Update (IPS Integration)</h1>
Job: http://dpjenkins01.{pop}.nskope.net:8080/job/ansible_role_ipsnat/
Purpose: Create NAT mappings between nsproxy and IPS nodes
Parameters:
  <ul>
<li>ROLE: ipsnat</li>
</ul>
  <ul>
<li>LIMIT: ips (NOT ips<em> - excludes ipsecgw nodes)</li>
</ul>
Required: After new dppool/nsproxy node addition</p>
<p><h1>4. Node Validation</h1>
Job: http://ppe-jenkins01.sv5.nskope.net:8080/view/MANUAL-VALIDATION/job/nsproxy_node_validation_manual/
Purpose: Validate gateway IP in route tables
Parameters:
  <ul>
<li>ANSIBLE_INVENTORY_GROUP: dataplane/dataplane2/ALL/NONE</li>
</ul>
  <ul>
<li>POP_NAME: </li>
</ul>
  <ul>
<li>HOSTNAME_FQDN: </li>
</ul>
</code></pre></p>
<p><h4>Additional Interface Management (Bare Metal)</h4>
<pre><code><h1>For Bare Metal dppool builds requiring additional interfaces</h1>
Job: http://ppe-jenkins01.sv5.nskope.net:8080/job/baremetal_add_interface_nsproxy_dppool/
Purpose: Add VLAN interfaces (600/601) for nsproxy hosts
Required Roles:
  <ul>
<li>nslbrsrouting: Main routing configuration  </li>
</ul>
  <ul>
<li>nsproxy_revroutes: Reverse route configuration</li>
</ul>
</code></pre></p>
<h3>LCO Deployment Integration</h3>
<p><h4>Software Deployment Workflow</h4>
<pre><code><h1>Component Deployment</h1>
Job: http://dpjenkins01.{pop}.nskope.net:8080/job/deployment_installjob_launcher/
Components (in order):
  1. nslbrsrouting           # Routing configuration
  2. nsproxy_revroutes       # Reverse routes
  3. resolvconf-fix          # DNS resolution fixes
  4. one_button_nsproxy      # Core nsproxy service
  5. one_button_nsproxy-api-sidecar  # API sidecar
  6. nstelegraf              # Monitoring agent</p>
<p><h1>Deployment URLs:</h1>
<h1>- Main: https://cdjenkins.sjc1.nskope.net/job/one_button_nsproxy/</h1>
<h1>- Sidecar: https://cdjenkins.sjc1.nskope.net/job/one_button_nsproxy-api-sidecar/</h1>
<h1>- Telegraf: http://dpjenkins01.$POP.nskope.net:8080/job/nstelegraf_installer/</h1>
</code></pre></p>
<h3>Validation and Monitoring</h3>
<p><h4>Post-Deployment Validation</h4>
<pre><code><h1>System Survey (from ESS Jenkins)</h1>
Job: http://essdpjenkins04.$POP.nskope.net:8080/job/survey_vm/
Purpose: Comprehensive system validation
Required: After all deployment steps complete</p>
<p><h1>Validation Tasks:</h1>
<h1>1. Verify routing tables exist and populated</h1>
<h1>2. Check policy rules configuration</h1>
<h1>3. Validate interface status and IP assignments</h1>
<h1>4. Confirm DNS resolution and connectivity</h1>
<h1>5. Test DSR functionality</h1>
</code></pre></p>
<h2>Troubleshooting Guide</h2>
<h3>Common Issues</h3>
<p><h4>1. Netplan Validation Failures</h4>
<pre><code><h1>Check netplan syntax</h1>
sudo netplan try</p>
<p><h1>Validate generated configuration</h1>
sudo netplan --debug generate</p>
<p><h1>Apply configuration manually</h1>
sudo netplan apply
</code></pre></p>
<p><h4>2. Interface Discovery Problems</h4>
<pre><code><h1>Check interface status</h1>
ip addr show</p>
<p><h1>Verify netifaces detection</h1>
python3 -c "import netifaces; print(netifaces.interfaces())"</p>
<p><h1>Check routing tables</h1>
ip route show table all
</code></pre></p>
<p><h4>3. Service Detection Issues</h4>
<pre><code><h1>Check networking service status</h1>
systemctl status networking</p>
<p><h1>Check systemd-networkd status  </h1>
systemctl status systemd-networkd</p>
<p><h1>Check netplan configuration</h1>
ls -la /etc/netplan/</p>
<p><h1>Manual service detection test</h1>
python3 -c "
from deploy_routing import detect_networking_services
print(detect_networking_services())
"
</code></pre></p>
<p><h4>5. Bond0.410 Interface Issues</h4>
<pre><code><h1>Check if bond0.410 interface exists</h1>
ip a | grep bond0.410</p>
<p><h1>For VMs - reboot may be required</h1>
sudo reboot</p>
<p><h1>For Bare Metal - install patch and configure</h1>
sudo apt update && apt install baremetal-interface-patch
cp /etc/network/interfaces.d/polaris0.cfg /etc/network/interfaces.d/polaris0.cfg.bk
baremetal-interface-patch --patch-interface
baremetal-interface-patch --generate-network-config > /etc/network/interfaces.d/polaris0.cfg
sudo ifup bond0.410</p>
<p><h1>Verify NAT routing tables exist</h1>
ls /etc/network/</em>110<em>
<h1>Should show: ns_configure_rules.110.ROUTING, ns_deconfigure_rules.110.ROUTING</h1>
</code></pre></p>
<p><h4>6. Duplicate NAT Rules Cleanup</h4>
<pre><code><h1>Check for duplicate fw mark rules</h1>
sudo ip rule show | grep fwmark</p>
<p><h1>Remove duplicate entries (common after automation runs)</h1>
sudo ip rule del fwmark 20 table 120  # Remove old decimal format
sudo ip rule del fwmark 10 table 110  # Remove old decimal format</p>
<p><h1>Verify correct rules remain (hexadecimal format)</h1>
sudo ip rule show
<h1>Should show:</h1>
<h1>32759: from all fwmark 0x14 lookup 120_nat</h1>
<h1>32760: from all fwmark 0xa lookup 110_nat</h1>
</code></pre></p>
<p><h4>7. Manual vs Automated Configuration Conflicts</h4>
<pre><code><h1>Check for conflicting manual configuration</h1>
sudo grep -r "ip rule add" /etc/network/interfaces</em>
sudo grep -r "ip route add" /etc/network/interfaces<em></p>
<p><h1>Verify automation-generated files</h1>
ls -la /etc/network/ns_</em>rules<em>
ls -la /etc/netplan/99-nslbrsrouting</em></p>
<p><h1>Compare manual vs automated configurations</h1>
cat /etc/network/interfaces | grep -A5 -B5 "ip rule\|ip route"
cat /etc/network/ns_configure_rules.<em>.ROUTING
</code></pre></p>
<p><h4>8. Jenkins Job Troubleshooting</h4>
<pre><code><h1>Inventory not updated - run infrastructure job</h1>
curl -X POST http://ppe-jenkins01.sv5.nskope.net:8080/job/infrastructure/build</p>
<p><h1>Reverse routes missing - check inventory and run job</h1>
<h1>Ensure host is in correct ansible groups: dataplane, dataplane2, edge-nsproxy</h1>
ansible-inventory --host  | jq '.group_names'</p>
<p><h1>NAT rules not applied - check IPS pool status</h1>
ansible ips -m shell -a "iptables-save | grep "</p>
<p><h1>Node validation failures - check routing table</h1>
sudo ip route show table ingress_table
sudo ip rule show | grep -E "(32500|32650|32690)"
</code></pre></p>
<h3>Configuration Status Check</h3>
<pre><code><h1>Check what configurations were generated</h1>
ls -la /etc/network/ns_</em>rules<em>
ls -la /etc/netplan/99-nslbrsrouting</em></p>
<p><h1>Verify file permissions</h1>
stat /etc/netplan/99-nslbrsrouting-generated.yaml</p>
<p><h1>Test netplan syntax without applying</h1>
sudo netplan --debug try --timeout 30
</code></pre>
<p><h3>Log Locations</h3>
<ul>
<li><strong>Ansible Logs</strong>: <code>/var/log/ansible/</code></li>
<li><strong>System Network Logs</strong>: <code>journalctl -u systemd-networkd</code></li>
<li><strong>Script Output</strong>: Captured in Ansible task output</li>
</ul></p>
<h2>Operational Procedures</h2>
<h3>New Node Provisioning Workflow</h3>
<p><h4>Phase 1: Infrastructure Preparation</h4>
<strong>IP Allocation</strong>: Reserve required IP addresses via Polaris
<ul>
<li>Private VLAN 400: dppool-name.{pop}.nskope.net (ingress)</li>
<li>Private VLAN 400: dppool-name-egress.{pop}.nskope.net (egress)</li>
<li>Public VLAN 100: dppool-name.ext.{pop}.nskope.net (public)</li>
<li>VLAN 600: dppool-name-bond0600-vlan600.{pop}.nskope.net (optional)</li>
<li>VLAN 601: dppool-name-bond0601-vlan601.{pop}.nskope.net (optional)</li>
</ul></p>
<p><strong>Inventory Update</strong>: Add host to infrastructure repository
<ul>
<li>Group assignments: dataplane, dataplane2, edge-nsproxy</li>
<li>Variable definitions: VIP assignments, interface mappings</li>
</ul></p>
<p><h4>Phase 2: System Provisioning</h4>
<ul>
<li><strong>Host Deployment</strong>: via Polaris oneshot-provision</li>
<li><strong>Network Configuration</strong>: Automated via Ansible roles</li>
<li><strong>Service Installation</strong>: LCO deployment workflow</li>
</ul></p>
<p><h4>Phase 3: Routing Configuration</h4>
<ul>
<li><strong>Base Routing</strong>: nslbrsrouting role execution</li>
<li><strong>Reverse Routes</strong>: nsproxy_revroutes role execution</li>
<li><strong>NAT Integration</strong>: ipsnat role for IPS pool mapping</li>
<li><strong>Interface Management</strong>: Additional VLANs if required</li>
</ul></p>
<h3>Environment-Specific Procedures</h3>
<p><h4>SV5 Datacenter (Legacy)</h4>
<pre><code><h1>Manual routing table setup still required</h1>
echo "1 ingress_table" >> /etc/iproute2/rt_tables</p>
<p><h1>Network interface configuration via templates</h1>
<h1>Variables: dppool-name.mgt.sv5.nskope.net, dppool-name.sv5.nskope.net, etc.</h1>
<h1>Custom gateway: 192.168.100.1</h1>
<h1>Management subnet: 192.168.106.0/23</h1>
</code></pre></p>
<p><h4>Non-SV5 Datacenters (Modern)</h4>
<pre><code><h1>Fully automated via deploy_routing.py</h1>
<h1>Supports both Physical DC and AWS configurations</h1>
<h1>Environment detection via NSLB_EGRESS_GW_VIP variable</h1>
<h1>Multi-service networking with netplan/ifupdown dual configuration</h1>
</code></pre></p>
<h3>Post-Deployment Validation Checklist</h3>
<p><h4>Routing Validation</h4>
<ul>
<li>✅ Verify ingress_table exists: <code>ip route show table ingress_table</code></li>
</ul>
✅ Check policy rules: ip rule show | grep -E "(32500|32650|32690)"</p>
<ul>
<li>✅ Validate NAT rules: <code>ip rule show | grep fwmark</code></li>
<li>✅ Confirm interface status: <code>ip addr show bond0.410</code></li>
</ul>
<p><h4>Service Validation</h4>
<ul>
<li>✅ Run survey_vm from ESS Jenkins</li>
<li>✅ Execute nsproxy_node_validation_manual</li>
<li>✅ Verify IPS NAT mappings</li>
<li>✅ Test connectivity to gateway pools</li>
</ul></p>
<p><h4>Configuration Files Validation</h4>
<ul>
<li>✅ Legacy format: <code>ls /etc/network/ns_<em>rules</em></code></li>
<li>✅ Modern format: <code>ls /etc/netplan/99-nslbrsrouting<em></code></li>
<li>✅ Routing tables: <code>cat /etc/iproute2/rt_tables | grep ingress</code></li>
<li>✅ Interface immutability: <code>lsattr /etc/network/interfaces</code></li>
</ul></p>
<h3>Emergency Procedures</h3>
<p><h4>Rollback Scenarios</h4>
<pre><code><h1>Disable automated configuration temporarily</h1>
sudo chattr -i /etc/network/interfaces
sudo systemctl stop networking</p>
<p><h1>Restore manual configuration from backup</h1>
cp /etc/network/interfaces.bak /etc/network/interfaces</p>
<p><h1>Re-enable interface immutability</h1>
sudo chattr +i /etc/network/interfaces
sudo systemctl start networking
</code></pre></p>
<p><h4>Configuration Repair</h4>
<pre><code><h1>Re-run automation for specific host</h1>
ansible-playbook -i inventory/production site.yml --limit  --tags nslbrsrouting</p>
<p><h1>Manual NAT rules cleanup</h1>
sudo ip rule del fwmark 10 table 110  # Remove duplicates
sudo ip rule del fwmark 20 table 120  # Remove duplicates</p>
<p><h1>Restart networking service</h1>
sudo systemctl restart systemd-networkd  # For netplan systems
sudo systemctl restart networking       # For ifupdown systems
</code></pre></p>
<h2>Security Considerations</h2>
<p><h3>File Permissions</h3>
<ul>
<li>Configuration files: <code>644 (rw-r--r--)</code></li>
<li>Script files: <code>755 (rwxr-xr-x)</code></li>
<li>Temporary files: Cleaned up after execution</li>
</ul></p>
<p><h3>Network Security</h3>
<ul>
<li>VIP addresses isolated to dummy interfaces</li>
<li>Policy routing prevents cross-table leakage</li>
<li>Gateway access controlled via firewall rules</li>
</ul></p>
<h2>Maintenance Procedures</h2>
<p><h3>Regular Tasks</h3>
<ul>
<li><strong>Configuration Validation</strong>: Weekly netplan syntax checks</li>
<li><strong>Route Table Verification</strong>: Monthly routing table audits</li>
<li><strong>Interface Monitoring</strong>: Continuous interface status monitoring</li>
</ul></p>
<p><h3>Update Procedures</h3>
<ul>
<li>Test configuration changes in staging environment</li>
<li>Use Ansible check mode for validation</li>
<li>Deploy with rolling restart to maintain availability</li>
<li>Verify routing functionality post-deployment</li>
</ul></p>
<h2>Performance Considerations</h2>
<p><h3>Optimization Tips</h3>
<ul>
<li>Use policy routing for traffic segregation</li>
<li>Minimize routing table lookups</li>
<li>Configure appropriate interface MTU sizes</li>
<li>Monitor interface utilization</li>
</ul></p>
<p><h3>Scalability Factors</h3>
<ul>
<li>Maximum VIPs per interface: Limited by kernel</li>
<li>Routing table size: Impacts lookup performance</li>
<li>Gateway pool size: Affects failover time</li>
</ul></p>
<h2>Implementation Status and Validation</h2>
<h3>Current Implementation Status</h3>
<p><strong>Multi-Service Support: COMPLETE</strong></p>
<ul>
<li>Automatic service detection implemented</li>
<li>Netplan YAML generation for systemd-networkd</li>
<li>Legacy ifupdown rule generation</li>
<li>Dual-configuration mode for compatibility</li>
<li>Graceful fallback handling</li>
<li>Atomic file writing to prevent corruption</li>
</ul>
<h3>Validation and Testing</h3>
<h4>Test Scenarios</h4>
<p>| Test Case 
| Environment 
| Expected Result 
| Validation Method </p>
<p>| Netplan-Only DSR 
| Ubuntu 20.04 LTS (systemd-networkd active) 
| netplan YAML generated (+ ifupdown fallback) 
| <code>netplan try</code> </p>
<p>| Networking-Only DSR 
| Ubuntu 16.04 
| ifupdown rules generated 
| <code>ip rule show</code> </p>
<p>| Dual-Service DSR 
| Ubuntu 18.04/20.04 
| Both configurations generated 
| Both validation methods </p>
<p>| Service Detection 
| Any environment 
| Correct service identification 
| Script output logging </p>
<p><h4>Manual Validation Commands</h4>
<pre><code><h1>Test script execution with dry-run</h1>
python3 deploy_routing.py -O GW_LVS_DSR -V 172.16.1.100 -L 172.16.1.10</p>
<p><h1>Expected output includes:</h1>
<h1>"Detected networking services: {'netplan': True, 'networking': False, ...}"</h1>
<h1>"Generated configuration formats:"</h1>
<h1>"✓ Legacy ifupdown configuration (for networking service)"</h1>
<h1>"✓ Modern netplan configuration (for systemd-networkd)"</h1>
<h1>"Service compatibility:"</h1>
<h1>"→ Netplan-only mode - modern systemd-networkd configuration"</h1>
</code></pre></p>
<h3>Migration Path</h3>
<p>The implementation provides a smooth migration path for infrastructure modernization:</p>
<ul>
<li><strong>Phase 1</strong>: Deploy dual-configuration support (current implementation)</li>
<li><strong>Phase 2</strong>: Gradually migrate hosts to netplan-based systems</li>
<li><strong>Phase 3</strong>: Validate DSR functionality on new networking stack</li>
<li><strong>Phase 4</strong>: Optional cleanup of legacy ifupdown configurations</li>
</ul>
<h2>References and Additional Information</h2>
<p><h3>Related Documentation</h3>
<ul>
<li><a href="https://netplan.io/reference">Netplan Configuration Reference</a></li>
<li><a href="https://www.freedesktop.org/software/systemd/man/systemd-networkd.html">systemd-networkd Documentation</a></li>
<li><a href="https://wiki.debian.org/NetworkConfiguration">Debian Network Configuration</a></li>
<li><a href="https://manpages.ubuntu.com/manpages/focal/man8/ip-rule.8.html">Linux Policy Routing (ip rule)</a></li>
</ul></p>
<p><h3>Internal Resources</h3>
<ul>
<li><strong>Git Repository</strong>: <code>infrastructure.git</code> - Branch: <code>eng-495439-nsproxy-netplan-routing-config</code></li>
<li><strong>Jira Ticket</strong>: ENG-495439 - Netplan routing configuration compatibility</li>
<li><strong>Ansible Roles</strong>: <code>nslbrsrouting</code>, <code>nsproxy_revroutes</code></li>
<li><strong>Infrastructure Team</strong>: Contact for questions and updates</li>
</ul></p>
<h3>Change History</h3>
<p>| Date 
| Version 
| Changes 
| Author 
| Jira/Ticket </p>
<p>| 2025-10-02 
| 2.0 
| Added multi-service networking support, netplan compatibility 
| Michael Huo 
| ENG-495439 </p>
<p>| 2025-02-21 
| 1.12 
| Use replace clause instead of add when managing routes 
| Deepinder Setia 
| ENG-583850 </p>
<p>| 2023-08-10 
| 1.11 
| Avoid using interface name as it could be dynamic in OpenStack 
| Deepinder Setia 
| ENG-266108 </p>
<p>| 2023-02-01 
| 1.10 
| Add static routes to NAT HC hosts via egress NAT interface 
| Deepinder Setia 
| ENG-228210 </p>
<p>| 2023-01-17 
| 1.9 
| Revert NAT HC hosts static routes (temporary rollback) 
| Deepinder Setia 
| ENG-228210 </p>
<p>| 2023-01-03 
| 1.8 
| Add static routes to NAT HC hosts via egress NAT interface (initial) 
| Deepinder Setia 
| ENG-228210 </p>
<p>| 2022-02-15 
| 1.7 
| Create defaults for egress NAT group variables 
| Kallol Banerjee 
| ENG-159894 </p>
<p>| 2022-01-26 
| 1.6 
| Infrastructure improvements (Egress IP related) 
| Kallol Banerjee 
| ENG-135345 </p>
<p>| 2022-01-24 
| 1.5 
| Major: Added egress IP policy-based routing from proxy 
| Kallol Banerjee 
| ENG-135345 </p>
<p>| 2021-04-14 
| 1.4 
| Avoid using routing table number 220 
| bshah270906 
| N/A </p>
<p>| 2020-03-10 
| 1.3 
| Major: Support multiple load balancer VIPs 
| swu-ns 
| ENG-97991 </p>
<p>| 2019-02-19 
| 1.2 
| Ensure nsproxy egress routing after scripts refactoring 
| Shashank Naik 
| OPS-21993 </p>
<p>| 2018-12-12 
| 1.1 
| Initial nslbrsrouting role implementation 
| Shailendra (netskope) 
| N/A </p>
<p>| 2017-06-19 
| 1.0 
| Initial DSR routing automation implementation 
| Shashank Naik 
| N/A </p>
<h3>Major Changes Summary (2017-2025)</h3>
<p><h4>Foundation Era (2017-2020)</h4>
<strong>Key Contributors:</strong> Shashank Naik, Shailendra, swu-ns</p>
<ul>
<li><strong>Core DSR Automation</strong>: Shashank Naik established the foundational Direct Server Return routing system with basic VIP and gateway configuration</li>
<li><strong>Ansible Integration</strong>: Shailendra structured the automation into reusable Ansible roles (nslbrsrouting, nsproxy_revroutes)</li>
<li><strong>Multi-VIP Architecture</strong>: swu-ns expanded support from single to multiple load balancer VIPs, enabling complex gateway configurations</li>
</ul>
<p><h4>Egress NAT Era (2021-2022)</h4>
<strong>Key Contributors:</strong> bshah270906, Kallol Banerjee</p>
<ul>
<li><strong>Advanced Egress Capabilities</strong>: Complete egress IP policy-based routing implementation with NSPROXY_EGRESS_NAT operation mode</li>
<li><strong>Enterprise Defaults</strong>: Standardized configuration variables (EGRESS_NAT_INTERFACE, RT_TABLE_IDS, SO_MARKS) for consistent deployment</li>
<li><strong>Routing Table Optimization</strong>: Fixed conflicts and improved routing table number management</li>
</ul>
<p><h4>Cloud & Stability Era (2023-2025)</h4>
<strong>Key Contributors:</strong> Deepinder Setia</p>
<ul>
<li><strong>Cloud Platform Support</strong>: Enhanced OpenStack compatibility with dynamic interface name handling</li>
<li><strong>NAT Health Check Integration</strong>: Added static routes for NAT health check hosts via egress interfaces</li>
<li><strong>Route Management Improvements</strong>: Switched from 'add' to 'replace' operations for more reliable route updates</li>
</ul>
<p><h4>Modern Networking Era (2025)</h4>
<strong>Key Contributors:</strong> Michael Huo</p>
<ul>
<li><strong>Multi-Service Architecture</strong>: Revolutionary support for netplan/systemd-networkd alongside legacy ifupdown systems</li>
<li><strong>Intelligent Service Detection</strong>: Automatic detection and dual-configuration generation for maximum compatibility</li>
<li><strong>Ubuntu LTS Modernization</strong>: Full support for Ubuntu 20.04 LTS netplan-based networking while maintaining backward compatibility</li>
</ul>
<h3>Evolution Summary: Shashank Naik → Michael Huo</h3>
<p>| Aspect 
| Shashank's Foundation (2017) 
| Michael's Enhancement (2025) </p>
<p>| <strong>Network Backend</strong> 
| Single ifupdown/networking service 
| Multi-service: netplan + ifupdown + systemd-networkd </p>
<p>| <strong>Configuration Format</strong> 
| Legacy rule-based files only 
| Dual-format: YAML + legacy rules </p>
<p>| <strong>Service Detection</strong> 
| Static assumptions 
| Intelligent automatic detection </p>
<p>| <strong>Ubuntu Support</strong> 
| 16.04 LTS focused 
| 16.04-20.04 LTS comprehensive </p>
<p>| <strong>Deployment Strategy</strong> 
| Single configuration path 
| Dual-configuration with failover </p>
<p>| <strong>Future Readiness</strong> 
| Traditional networking 
| Modern declarative networking </p>
<p></em>This documentation covers the automated routing system for Netskope proxy infrastructure with comprehensive multi-service networking support and operational runbook integration. For questions or updates, contact the Infrastructure Engineering team.<em></p>
<h2>Runbook Integration Summary</h2>
<h3>Automation vs Manual Procedures</h3>
<p>| Operational Task 
| Manual Method (Runbook) 
| Automated Method (Current) 
| Status </p>
<p>| <strong>IP Allocation</strong> 
| Manual Polaris commands 
| Integrated with Ansible inventory 
| ✅ </em>Automated<em> </p>
<p>| <strong>Network Interface Setup</strong> 
| Manual /etc/network/interfaces editing 
| deploy_routing.py + Jinja2 templates 
| ✅ </em>Automated<em> </p>
<p>| <strong>Routing Table Configuration</strong> 
| Manual iproute2 commands 
| 99-ns-config hook script automation 
| ✅ </em>Automated<em> </p>
<p>| <strong>Policy Rules Management</strong> 
| Manual ip rule commands 
| Generated ns_configure_rules files 
| ✅ </em>Automated<em> </p>
<p>| <strong>Jenkins Job Orchestration</strong> 
| Manual job execution sequence 
| Integrated deployment pipeline 
| 🔄 </em>Semi-Automated<em> </p>
<p>| <strong>Bond0.410 Interface Setup</strong> 
| Manual baremetal-interface-patch 
| Baremetal Ansible role integration 
| 🔄 </em>Conditional<em> </p>
<p>| <strong>NAT Rules Configuration</strong> 
| Manual iptables + ip rule commands 
| ipsnat role automation 
| ✅ </em>Automated<em> </p>
<p>| <strong>Validation and Testing</strong> 
| Manual command verification 
| Jenkins validation jobs 
| 🔄 </em>Semi-Automated* </p>
<h3>Critical Manual Steps Still Required</h3>
<p><h4>1. Pre-Deployment (Manual)</h4>
<ul>
<li>IP address allocation via Polaris interface</li>
<li>Infrastructure inventory updates (Git workflow)</li>
<li>Host provisioning trigger</li>
</ul></p>
<p><h4>2. Post-Deployment (Manual)</h4>
<ul>
<li>Jenkins job sequence execution (can be automated)</li>
<li>Final validation via survey_vm</li>
<li>Performance testing and monitoring setup</li>
</ul></p>
<h3>Operational Improvements Achieved</h3>
<ul>
<li><strong>🚀 99% Configuration Automation</strong>: From manual interface editing to automated dual-format generation</li>
<li><strong>🔧 Multi-Service Support</strong>: Automatic detection and compatibility with all Ubuntu LTS versions</li>
<li><strong>📋 Standardized Procedures</strong>: Consistent deployment across Physical DC, AWS, and legacy environments</li>
<li><strong>🛡️ Error Reduction</strong>: Atomic file operations eliminate partial configuration states</li>
<li><strong>📊 Comprehensive Logging</strong>: Full audit trail of all configuration changes</li>
<li><strong>⚡ Faster Deployment</strong>: Reduced provisioning time from hours to minutes</li>
</ul>
<h2>Enhanced Future Roadmap</h2>
<p><h3>Planned Enhancements</h3>
<ul>
<li><strong>IPv6 Support</strong>: Extend DSR functionality for dual-stack environments</li>
<li><strong>Jenkins Workflow Automation</strong>: Full pipeline integration for post-deployment jobs</li>
<li><strong>Configuration Validation</strong>: Pre-deployment configuration syntax checking</li>
<li><strong>Monitoring Integration</strong>: Real-time routing table health monitoring</li>
<li><strong>Auto-Remediation</strong>: Automated recovery from configuration drift</li>
<li><strong>Bare Metal Integration</strong>: Automated bond0.410 interface management</li>
</ul></p>
<p><h3>Ubuntu LTS Evolution</h3>
<ul>
<li><strong>22.04 LTS Optimization</strong>: Native netplan workflow improvements</li>
<li><strong>24.04 LTS Preparation</strong>: Advanced networking feature integration</li>
<li><strong>Legacy Support</strong>: Continued 18.04/20.04 compatibility during transition</li>
</ul></p>
<p><h3>Operational Excellence Goals</h3>
<ul>
<li><strong>Zero-Touch Deployment</strong>: Complete automation from IP allocation to validation</li>
<li><strong>Self-Healing Infrastructure</strong>: Automatic detection and correction of configuration drift</li>
<li><strong>Predictive Monitoring</strong>: Proactive identification of potential routing issues</li>
<li><strong>Disaster Recovery</strong>: Automated backup and restore procedures</li>
</ul></p>
<p>---</p>
<p><strong>📋 Documentation Metadata</strong></p>
<p><ul>
<li><strong>Last Updated:</strong> January 2025</li>
<li><strong>Version:</strong> 2.2 (Runbook Integration)</li>
<li><strong>Sources:</strong> deploy_routing.py, Ansible playbooks, operational runbook, ENG-495439 fixes</li>
<li><strong>Integration Status:</strong> ✅ Technical automation + ✅ Operational procedures</li>
<li><strong>Coverage:</strong> Complete workflow from IP allocation to production validation</li>
</ul>
</p>
    </div>
</body>
</html>